Nicholas Warfield
due 9/4/19
homework 1

Assignment: Create a triangle where each vertex is a different color (top = blue, left = green, right = red). Additionally, their is a breathing effect where the entire triangle interpolates from black to its maximum color value.

Solution: Pretty straighforward, but requires several parts:
	1) Create Window: A window is needed so that we have somewhere to draw to, so we gotta do that first. The glfw library is used to handle all of this plus a few extras like getting user input. We also need to load the GLAD library before we do any openGL stuff.
	2) Shaders: Next up we load the shaders. Shaders are compiled at runtime from c style strings. Since I'm using files, I convert them to c strings. Then I create vertex shader with openGL and comiple it with the appropriate code. Repeat for the fragment shader, and check that both compiled succesfully. After that, the 2 shaders need to be attached and linked into a shader program. If the link is successful, we return the shader program so that we can use it in our program.
	3) VBA & VAO: Next up we need a vertex array object so that openGL has something it knows how to draw. The VBO lives in GPU memory and lets us send a whole bunch of verticies to the GPU all at once. Then we bind the buffer to the target, and copy the verticies we defined to it. The vertex array object will let us store the vertex attributes in the gpu as well. We need to bind it to the target, tell it how to read the input, and which attribute it corresponds to.
	4) Draw: At this point all of the heavy lifting has been done. We just need to tell openGL to use our shader program and draw a triangle. We also need to clear the canvas and redraw every frame to prevent artifacting.
	5) Breathing Effect: To create the breathing effect I used a sine function with time as it's input that will return values from 0 to 1. I then stored this value into a float uniform that my fragment shader had. Then multiply the color input by the scalar, and set the FragColor to this vector.

Discussion:
	-Graphics Pipeline: The first part of the graphics pipeline is the vertex shader, which is responsile for converting 3d vectors into another 3d vector that is usabe. Next is primitive assembly, which assembles all of the verticies into a shape. Next is the geometry shader, which can convert the primitive into other primitives. The 4th step is rasterization, which maps the primitive onto actual pixels, creating fragments. Next up is the fragment shader, which calculates the final color. The last step is alpha testing and blending which checks each pixel for conflicts with multiple colors and resolves them.
	Vertex Inputs: OpenGL renders 3d points and only 3d points. These points are normailized so they must be between -1 and 1, anything else will be off screen and not drawn. With these verticies we can draw user input. To do so, we create a buffer, bind it to gpu memory, then put the verticies and a drawing attribute in the buffer.
	-Shader Program: Shaders are a core part of the graphics pipeline, and they are comipled and linked at run time. We need to write our own vertex and fragment shader since their is no default for those. The vertex shader just passes position verticies to openGL since they are already normalized in this assignment. The fragment shader does the color, and in this case scales each vertex from black to its maximum color. In order to have this change over time, a uniform is used so that the main program can access and modify the scale factor.
	-Most challenging part? For me it was getting everything to compile. OpenGL is C library with a lot of quirks, like how the glad haeder file needs to be included before all other openGL headers. Fortunately, once I figured out how to use cmake it took care of most of the details.
	-What did I learn? A lot plus a bunch of review. I've woked with openGL shaders in unity before but I didn't have a full understanding of the graphics pipeline at the time. Now that I know the pipeline it opens up a lot more effects. I also learned how to use cmake which is pretty handy.
